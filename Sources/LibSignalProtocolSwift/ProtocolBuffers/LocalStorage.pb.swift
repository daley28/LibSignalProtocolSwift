// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: LocalStorage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Signal_Session: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localIdentityPublic: Data {
    get {return _localIdentityPublic ?? Data()}
    set {_localIdentityPublic = newValue}
  }
  /// Returns true if `localIdentityPublic` has been explicitly set.
  var hasLocalIdentityPublic: Bool {return self._localIdentityPublic != nil}
  /// Clears the value of `localIdentityPublic`. Subsequent reads from it will return its default value.
  mutating func clearLocalIdentityPublic() {self._localIdentityPublic = nil}

  var remoteIdentityPublic: Data {
    get {return _remoteIdentityPublic ?? Data()}
    set {_remoteIdentityPublic = newValue}
  }
  /// Returns true if `remoteIdentityPublic` has been explicitly set.
  var hasRemoteIdentityPublic: Bool {return self._remoteIdentityPublic != nil}
  /// Clears the value of `remoteIdentityPublic`. Subsequent reads from it will return its default value.
  mutating func clearRemoteIdentityPublic() {self._remoteIdentityPublic = nil}

  var rootKey: Data {
    get {return _rootKey ?? Data()}
    set {_rootKey = newValue}
  }
  /// Returns true if `rootKey` has been explicitly set.
  var hasRootKey: Bool {return self._rootKey != nil}
  /// Clears the value of `rootKey`. Subsequent reads from it will return its default value.
  mutating func clearRootKey() {self._rootKey = nil}

  var previousCounter: UInt32 {
    get {return _previousCounter ?? 0}
    set {_previousCounter = newValue}
  }
  /// Returns true if `previousCounter` has been explicitly set.
  var hasPreviousCounter: Bool {return self._previousCounter != nil}
  /// Clears the value of `previousCounter`. Subsequent reads from it will return its default value.
  mutating func clearPreviousCounter() {self._previousCounter = nil}

  var senderChain: Signal_Session.Chain {
    get {return _senderChain ?? Signal_Session.Chain()}
    set {_senderChain = newValue}
  }
  /// Returns true if `senderChain` has been explicitly set.
  var hasSenderChain: Bool {return self._senderChain != nil}
  /// Clears the value of `senderChain`. Subsequent reads from it will return its default value.
  mutating func clearSenderChain() {self._senderChain = nil}

  var receiverChains: [Signal_Session.Chain] = []

  var pendingPreKey: Signal_Session.PendingPreKey {
    get {return _pendingPreKey ?? Signal_Session.PendingPreKey()}
    set {_pendingPreKey = newValue}
  }
  /// Returns true if `pendingPreKey` has been explicitly set.
  var hasPendingPreKey: Bool {return self._pendingPreKey != nil}
  /// Clears the value of `pendingPreKey`. Subsequent reads from it will return its default value.
  mutating func clearPendingPreKey() {self._pendingPreKey = nil}

  var aliceBaseKey: Data {
    get {return _aliceBaseKey ?? Data()}
    set {_aliceBaseKey = newValue}
  }
  /// Returns true if `aliceBaseKey` has been explicitly set.
  var hasAliceBaseKey: Bool {return self._aliceBaseKey != nil}
  /// Clears the value of `aliceBaseKey`. Subsequent reads from it will return its default value.
  mutating func clearAliceBaseKey() {self._aliceBaseKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Chain: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderRatchetKey: Data {
      get {return _senderRatchetKey ?? Data()}
      set {_senderRatchetKey = newValue}
    }
    /// Returns true if `senderRatchetKey` has been explicitly set.
    var hasSenderRatchetKey: Bool {return self._senderRatchetKey != nil}
    /// Clears the value of `senderRatchetKey`. Subsequent reads from it will return its default value.
    mutating func clearSenderRatchetKey() {self._senderRatchetKey = nil}

    var senderRatchetKeyPrivate: Data {
      get {return _senderRatchetKeyPrivate ?? Data()}
      set {_senderRatchetKeyPrivate = newValue}
    }
    /// Returns true if `senderRatchetKeyPrivate` has been explicitly set.
    var hasSenderRatchetKeyPrivate: Bool {return self._senderRatchetKeyPrivate != nil}
    /// Clears the value of `senderRatchetKeyPrivate`. Subsequent reads from it will return its default value.
    mutating func clearSenderRatchetKeyPrivate() {self._senderRatchetKeyPrivate = nil}

    var chainKey: Signal_Session.Chain.ChainKey {
      get {return _chainKey ?? Signal_Session.Chain.ChainKey()}
      set {_chainKey = newValue}
    }
    /// Returns true if `chainKey` has been explicitly set.
    var hasChainKey: Bool {return self._chainKey != nil}
    /// Clears the value of `chainKey`. Subsequent reads from it will return its default value.
    mutating func clearChainKey() {self._chainKey = nil}

    var messageKeys: [Signal_Session.Chain.MessageKey] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ChainKey: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 {
        get {return _index ?? 0}
        set {_index = newValue}
      }
      /// Returns true if `index` has been explicitly set.
      var hasIndex: Bool {return self._index != nil}
      /// Clears the value of `index`. Subsequent reads from it will return its default value.
      mutating func clearIndex() {self._index = nil}

      var key: Data {
        get {return _key ?? Data()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _index: UInt32? = nil
      fileprivate var _key: Data? = nil
    }

    struct MessageKey: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var index: UInt32 {
        get {return _index ?? 0}
        set {_index = newValue}
      }
      /// Returns true if `index` has been explicitly set.
      var hasIndex: Bool {return self._index != nil}
      /// Clears the value of `index`. Subsequent reads from it will return its default value.
      mutating func clearIndex() {self._index = nil}

      var cipherKey: Data {
        get {return _cipherKey ?? Data()}
        set {_cipherKey = newValue}
      }
      /// Returns true if `cipherKey` has been explicitly set.
      var hasCipherKey: Bool {return self._cipherKey != nil}
      /// Clears the value of `cipherKey`. Subsequent reads from it will return its default value.
      mutating func clearCipherKey() {self._cipherKey = nil}

      var macKey: Data {
        get {return _macKey ?? Data()}
        set {_macKey = newValue}
      }
      /// Returns true if `macKey` has been explicitly set.
      var hasMacKey: Bool {return self._macKey != nil}
      /// Clears the value of `macKey`. Subsequent reads from it will return its default value.
      mutating func clearMacKey() {self._macKey = nil}

      var iv: Data {
        get {return _iv ?? Data()}
        set {_iv = newValue}
      }
      /// Returns true if `iv` has been explicitly set.
      var hasIv: Bool {return self._iv != nil}
      /// Clears the value of `iv`. Subsequent reads from it will return its default value.
      mutating func clearIv() {self._iv = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _index: UInt32? = nil
      fileprivate var _cipherKey: Data? = nil
      fileprivate var _macKey: Data? = nil
      fileprivate var _iv: Data? = nil
    }

    init() {}

    fileprivate var _senderRatchetKey: Data? = nil
    fileprivate var _senderRatchetKeyPrivate: Data? = nil
    fileprivate var _chainKey: Signal_Session.Chain.ChainKey? = nil
  }

  struct PendingPreKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var preKeyID: UInt32 {
      get {return _preKeyID ?? 0}
      set {_preKeyID = newValue}
    }
    /// Returns true if `preKeyID` has been explicitly set.
    var hasPreKeyID: Bool {return self._preKeyID != nil}
    /// Clears the value of `preKeyID`. Subsequent reads from it will return its default value.
    mutating func clearPreKeyID() {self._preKeyID = nil}

    var signedPreKeyID: Int32 {
      get {return _signedPreKeyID ?? 0}
      set {_signedPreKeyID = newValue}
    }
    /// Returns true if `signedPreKeyID` has been explicitly set.
    var hasSignedPreKeyID: Bool {return self._signedPreKeyID != nil}
    /// Clears the value of `signedPreKeyID`. Subsequent reads from it will return its default value.
    mutating func clearSignedPreKeyID() {self._signedPreKeyID = nil}

    var baseKey: Data {
      get {return _baseKey ?? Data()}
      set {_baseKey = newValue}
    }
    /// Returns true if `baseKey` has been explicitly set.
    var hasBaseKey: Bool {return self._baseKey != nil}
    /// Clears the value of `baseKey`. Subsequent reads from it will return its default value.
    mutating func clearBaseKey() {self._baseKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _preKeyID: UInt32? = nil
    fileprivate var _signedPreKeyID: Int32? = nil
    fileprivate var _baseKey: Data? = nil
  }

  init() {}

  fileprivate var _localIdentityPublic: Data? = nil
  fileprivate var _remoteIdentityPublic: Data? = nil
  fileprivate var _rootKey: Data? = nil
  fileprivate var _previousCounter: UInt32? = nil
  fileprivate var _senderChain: Signal_Session.Chain? = nil
  fileprivate var _pendingPreKey: Signal_Session.PendingPreKey? = nil
  fileprivate var _aliceBaseKey: Data? = nil
}

struct Signal_Record: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentSession: Signal_Session {
    get {return _currentSession ?? Signal_Session()}
    set {_currentSession = newValue}
  }
  /// Returns true if `currentSession` has been explicitly set.
  var hasCurrentSession: Bool {return self._currentSession != nil}
  /// Clears the value of `currentSession`. Subsequent reads from it will return its default value.
  mutating func clearCurrentSession() {self._currentSession = nil}

  var previousSessions: [Signal_Session] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentSession: Signal_Session? = nil
}

struct Signal_PreKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Signal_PreKey.PublicPart {
    get {return _publicKey ?? Signal_PreKey.PublicPart()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var privateKey: Data {
    get {return _privateKey ?? Data()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublicPart: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var key: Data {
      get {return _key ?? Data()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt32? = nil
    fileprivate var _key: Data? = nil
  }

  init() {}

  fileprivate var _publicKey: Signal_PreKey.PublicPart? = nil
  fileprivate var _privateKey: Data? = nil
}

struct Signal_SignedPreKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Signal_SignedPreKey.PublicPart {
    get {return _publicKey ?? Signal_SignedPreKey.PublicPart()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var privateKey: Data {
    get {return _privateKey ?? Data()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublicPart: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var key: Data {
      get {return _key ?? Data()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var signature: Data {
      get {return _signature ?? Data()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    mutating func clearSignature() {self._signature = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt32? = nil
    fileprivate var _key: Data? = nil
    fileprivate var _signature: Data? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  init() {}

  fileprivate var _publicKey: Signal_SignedPreKey.PublicPart? = nil
  fileprivate var _privateKey: Data? = nil
}

struct Signal_KeyPair: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var privateKey: Data {
    get {return _privateKey ?? Data()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Data? = nil
  fileprivate var _privateKey: Data? = nil
}

struct Signal_SenderKeyState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var senderKeyID: UInt32 {
    get {return _senderKeyID ?? 0}
    set {_senderKeyID = newValue}
  }
  /// Returns true if `senderKeyID` has been explicitly set.
  var hasSenderKeyID: Bool {return self._senderKeyID != nil}
  /// Clears the value of `senderKeyID`. Subsequent reads from it will return its default value.
  mutating func clearSenderKeyID() {self._senderKeyID = nil}

  var senderChainKey: Signal_SenderKeyState.SenderChainKey {
    get {return _senderChainKey ?? Signal_SenderKeyState.SenderChainKey()}
    set {_senderChainKey = newValue}
  }
  /// Returns true if `senderChainKey` has been explicitly set.
  var hasSenderChainKey: Bool {return self._senderChainKey != nil}
  /// Clears the value of `senderChainKey`. Subsequent reads from it will return its default value.
  mutating func clearSenderChainKey() {self._senderChainKey = nil}

  var senderSigningKey: Signal_SenderKeyState.SenderSigningKey {
    get {return _senderSigningKey ?? Signal_SenderKeyState.SenderSigningKey()}
    set {_senderSigningKey = newValue}
  }
  /// Returns true if `senderSigningKey` has been explicitly set.
  var hasSenderSigningKey: Bool {return self._senderSigningKey != nil}
  /// Clears the value of `senderSigningKey`. Subsequent reads from it will return its default value.
  mutating func clearSenderSigningKey() {self._senderSigningKey = nil}

  var senderMessageKeys: [Signal_SenderKeyState.SenderMessageKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SenderChainKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var iteration: UInt32 {
      get {return _iteration ?? 0}
      set {_iteration = newValue}
    }
    /// Returns true if `iteration` has been explicitly set.
    var hasIteration: Bool {return self._iteration != nil}
    /// Clears the value of `iteration`. Subsequent reads from it will return its default value.
    mutating func clearIteration() {self._iteration = nil}

    var seed: Data {
      get {return _seed ?? Data()}
      set {_seed = newValue}
    }
    /// Returns true if `seed` has been explicitly set.
    var hasSeed: Bool {return self._seed != nil}
    /// Clears the value of `seed`. Subsequent reads from it will return its default value.
    mutating func clearSeed() {self._seed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _iteration: UInt32? = nil
    fileprivate var _seed: Data? = nil
  }

  struct SenderMessageKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var iteration: UInt32 {
      get {return _iteration ?? 0}
      set {_iteration = newValue}
    }
    /// Returns true if `iteration` has been explicitly set.
    var hasIteration: Bool {return self._iteration != nil}
    /// Clears the value of `iteration`. Subsequent reads from it will return its default value.
    mutating func clearIteration() {self._iteration = nil}

    var seed: Data {
      get {return _seed ?? Data()}
      set {_seed = newValue}
    }
    /// Returns true if `seed` has been explicitly set.
    var hasSeed: Bool {return self._seed != nil}
    /// Clears the value of `seed`. Subsequent reads from it will return its default value.
    mutating func clearSeed() {self._seed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _iteration: UInt32? = nil
    fileprivate var _seed: Data? = nil
  }

  struct SenderSigningKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var `public`: Data {
      get {return _public ?? Data()}
      set {_public = newValue}
    }
    /// Returns true if ``public`` has been explicitly set.
    var hasPublic: Bool {return self._public != nil}
    /// Clears the value of ``public``. Subsequent reads from it will return its default value.
    mutating func clearPublic() {self._public = nil}

    var `private`: Data {
      get {return _private ?? Data()}
      set {_private = newValue}
    }
    /// Returns true if ``private`` has been explicitly set.
    var hasPrivate: Bool {return self._private != nil}
    /// Clears the value of ``private``. Subsequent reads from it will return its default value.
    mutating func clearPrivate() {self._private = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _public: Data? = nil
    fileprivate var _private: Data? = nil
  }

  init() {}

  fileprivate var _senderKeyID: UInt32? = nil
  fileprivate var _senderChainKey: Signal_SenderKeyState.SenderChainKey? = nil
  fileprivate var _senderSigningKey: Signal_SenderKeyState.SenderSigningKey? = nil
}

struct Signal_SenderKeyRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var senderKeyStates: [Signal_SenderKeyState] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "Signal"

extension Signal_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localIdentityPublic"),
    2: .same(proto: "remoteIdentityPublic"),
    3: .same(proto: "rootKey"),
    4: .same(proto: "previousCounter"),
    5: .same(proto: "senderChain"),
    6: .same(proto: "receiverChains"),
    7: .same(proto: "pendingPreKey"),
    8: .same(proto: "aliceBaseKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._localIdentityPublic) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._remoteIdentityPublic) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._rootKey) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._previousCounter) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._senderChain) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.receiverChains) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._pendingPreKey) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._aliceBaseKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._localIdentityPublic {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remoteIdentityPublic {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rootKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._previousCounter {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._senderChain {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.receiverChains.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receiverChains, fieldNumber: 6)
    }
    try { if let v = self._pendingPreKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._aliceBaseKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Session, rhs: Signal_Session) -> Bool {
    if lhs._localIdentityPublic != rhs._localIdentityPublic {return false}
    if lhs._remoteIdentityPublic != rhs._remoteIdentityPublic {return false}
    if lhs._rootKey != rhs._rootKey {return false}
    if lhs._previousCounter != rhs._previousCounter {return false}
    if lhs._senderChain != rhs._senderChain {return false}
    if lhs.receiverChains != rhs.receiverChains {return false}
    if lhs._pendingPreKey != rhs._pendingPreKey {return false}
    if lhs._aliceBaseKey != rhs._aliceBaseKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_Session.Chain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.protoMessageName + ".Chain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderRatchetKey"),
    2: .same(proto: "senderRatchetKeyPrivate"),
    3: .same(proto: "chainKey"),
    4: .same(proto: "messageKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._senderRatchetKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._senderRatchetKeyPrivate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._chainKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.messageKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderRatchetKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderRatchetKeyPrivate {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._chainKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.messageKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Session.Chain, rhs: Signal_Session.Chain) -> Bool {
    if lhs._senderRatchetKey != rhs._senderRatchetKey {return false}
    if lhs._senderRatchetKeyPrivate != rhs._senderRatchetKeyPrivate {return false}
    if lhs._chainKey != rhs._chainKey {return false}
    if lhs.messageKeys != rhs.messageKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_Session.Chain.ChainKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.Chain.protoMessageName + ".ChainKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Session.Chain.ChainKey, rhs: Signal_Session.Chain.ChainKey) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_Session.Chain.MessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.Chain.protoMessageName + ".MessageKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "cipherKey"),
    3: .same(proto: "macKey"),
    4: .same(proto: "iv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._cipherKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._macKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._iv) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cipherKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._macKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._iv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Session.Chain.MessageKey, rhs: Signal_Session.Chain.MessageKey) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._cipherKey != rhs._cipherKey {return false}
    if lhs._macKey != rhs._macKey {return false}
    if lhs._iv != rhs._iv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_Session.PendingPreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_Session.protoMessageName + ".PendingPreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preKeyId"),
    2: .same(proto: "signedPreKeyId"),
    3: .same(proto: "baseKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._preKeyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._signedPreKeyID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._baseKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._preKeyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signedPreKeyID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._baseKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Session.PendingPreKey, rhs: Signal_Session.PendingPreKey) -> Bool {
    if lhs._preKeyID != rhs._preKeyID {return false}
    if lhs._signedPreKeyID != rhs._signedPreKeyID {return false}
    if lhs._baseKey != rhs._baseKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentSession"),
    2: .same(proto: "previousSessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentSession) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.previousSessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentSession {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.previousSessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.previousSessions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_Record, rhs: Signal_Record) -> Bool {
    if lhs._currentSession != rhs._currentSession {return false}
    if lhs.previousSessions != rhs.previousSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_PreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._privateKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._privateKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_PreKey, rhs: Signal_PreKey) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_PreKey.PublicPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_PreKey.protoMessageName + ".PublicPart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_PreKey.PublicPart, rhs: Signal_PreKey.PublicPart) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SignedPreKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedPreKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._privateKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._privateKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SignedPreKey, rhs: Signal_SignedPreKey) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SignedPreKey.PublicPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SignedPreKey.protoMessageName + ".PublicPart"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "key"),
    3: .same(proto: "signature"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SignedPreKey.PublicPart, rhs: Signal_SignedPreKey.PublicPart) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._key != rhs._key {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_KeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._privateKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._privateKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_KeyPair, rhs: Signal_KeyPair) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SenderKeyState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderKeyId"),
    2: .same(proto: "senderChainKey"),
    3: .same(proto: "senderSigningKey"),
    4: .same(proto: "senderMessageKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._senderKeyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._senderChainKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._senderSigningKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.senderMessageKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderKeyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._senderChainKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._senderSigningKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.senderMessageKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.senderMessageKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SenderKeyState, rhs: Signal_SenderKeyState) -> Bool {
    if lhs._senderKeyID != rhs._senderKeyID {return false}
    if lhs._senderChainKey != rhs._senderChainKey {return false}
    if lhs._senderSigningKey != rhs._senderSigningKey {return false}
    if lhs.senderMessageKeys != rhs.senderMessageKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState.SenderChainKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SenderKeyState.protoMessageName + ".SenderChainKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iteration"),
    2: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._iteration) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._seed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._iteration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SenderKeyState.SenderChainKey, rhs: Signal_SenderKeyState.SenderChainKey) -> Bool {
    if lhs._iteration != rhs._iteration {return false}
    if lhs._seed != rhs._seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState.SenderMessageKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SenderKeyState.protoMessageName + ".SenderMessageKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "iteration"),
    2: .same(proto: "seed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._iteration) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._seed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._iteration {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._seed {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SenderKeyState.SenderMessageKey, rhs: Signal_SenderKeyState.SenderMessageKey) -> Bool {
    if lhs._iteration != rhs._iteration {return false}
    if lhs._seed != rhs._seed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyState.SenderSigningKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signal_SenderKeyState.protoMessageName + ".SenderSigningKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
    2: .same(proto: "private"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._public) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._private) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._public {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._private {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SenderKeyState.SenderSigningKey, rhs: Signal_SenderKeyState.SenderSigningKey) -> Bool {
    if lhs._public != rhs._public {return false}
    if lhs._private != rhs._private {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signal_SenderKeyRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SenderKeyRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderKeyStates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.senderKeyStates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderKeyStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.senderKeyStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signal_SenderKeyRecord, rhs: Signal_SenderKeyRecord) -> Bool {
    if lhs.senderKeyStates != rhs.senderKeyStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
